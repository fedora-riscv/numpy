diff -ur numpy-0.9.8.orig/numpy/core/numeric.py numpy-0.9.8/numpy/core/numeric.py
--- numpy-0.9.8.orig/numpy/core/numeric.py	2006-05-17 18:48:38.000000000 -0400
+++ numpy-0.9.8/numpy/core/numeric.py	2006-09-05 16:23:00.000000000 -0400
@@ -11,6 +11,7 @@
            'array2string', 'get_printoptions', 'set_printoptions',
            'array_repr', 'array_str', 'set_string_function',
            'little_endian',
+           'fromiter',
            'indices', 'fromfunction',
            'load', 'loads', 'isscalar', 'binary_repr', 'base_repr',
            'ones', 'identity', 'allclose',
@@ -67,6 +68,10 @@
 
 # end Fernando's utilities
 
+def fromiter(obj, dtype=None):
+    obj = list(obj)
+    return array(obj, dtype=dtype)
+
 def extend_all(module):
     adict = {}
     for a in __all__:
diff -ur numpy-0.9.8.orig/numpy/core/src/arrayobject.c numpy-0.9.8/numpy/core/src/arrayobject.c
--- numpy-0.9.8.orig/numpy/core/src/arrayobject.c	2006-05-13 23:42:32.000000000 -0400
+++ numpy-0.9.8/numpy/core/src/arrayobject.c	2006-09-05 16:26:47.000000000 -0400
@@ -7287,9 +7287,10 @@
    adjusted */
 
 /*OBJECT_API
-  Adjusts previously broadcasted iterators so that the largest axis is not iterated 
-  over.  Returns dimension which is largest in the range [0,multi->nd).  A -1 
-  is returned if multi->nd == 0.
+  Adjusts previously broadcasted iterators so that the largest axis
+  is not iterated over.
+  Returns dimension which is largest in the range [0,multi->nd).
+  A -1 is returned if multi->nd == 0.
  */
 static int
 PyArray_RemoveLargest(PyArrayMultiIterObject *multi)
diff -ur numpy-0.9.8.orig/numpy/core/src/scalartypes.inc.src numpy-0.9.8/numpy/core/src/scalartypes.inc.src
--- numpy-0.9.8.orig/numpy/core/src/scalartypes.inc.src	2006-05-17 14:56:32.000000000 -0400
+++ numpy-0.9.8/numpy/core/src/scalartypes.inc.src	2006-09-05 16:28:32.000000000 -0400
@@ -1600,12 +1600,15 @@
 
 /* string and unicode inherit from Python Type first and so GET_ITEM is different to
    get to the Python Type.
+   ok is a work-around for a bug in complex_new that doesn't allocate
+   memory from the sub-types memory allocator.
  */
 
 /**begin repeat 
 #name=byte, short, int, long, longlong, ubyte, ushort, uint, ulong, ulonglong, float, double, longdouble, cfloat, cdouble, clongdouble, string, unicode, object#
 #TYPE=BYTE, SHORT, INT, LONG, LONGLONG, UBYTE, USHORT, UINT, ULONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, CFLOAT, CDOUBLE, CLONGDOUBLE, STRING, UNICODE, OBJECT#
 #num=1*16,0,0,1#
+#ok=0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,1,1,1#
 */
 static PyObject *
 @name@_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
@@ -1614,6 +1617,7 @@
 	PyObject *arr;
 	PyArray_Descr *typecode;
 
+#if @ok@
 	if (type->tp_bases && (PyTuple_GET_SIZE(type->tp_bases)==2)) {
 		PyTypeObject *sup;
 		PyObject *ret;
@@ -1625,6 +1629,7 @@
 		PyErr_Clear();
 		/* now do default conversion */
 	}
+#endif
 
 	if (!PyArg_ParseTuple(args, "O", &obj)) return NULL;
 
diff -ur numpy-0.9.8.orig/numpy/core/tests/test_scalarmath.py numpy-0.9.8/numpy/core/tests/test_scalarmath.py
--- numpy-0.9.8.orig/numpy/core/tests/test_scalarmath.py	2006-05-10 18:51:12.000000000 -0400
+++ numpy-0.9.8/numpy/core/tests/test_scalarmath.py	2006-09-05 16:28:58.000000000 -0400
@@ -11,55 +11,22 @@
          N.single, N.double, N.longdouble, N.csingle,
          N.cdouble, N.clongdouble]
 
-# These were generated using old umath
-typeconv = array([
-    [ 0,  1,  2,  3,  4,  5,  6,  5,  6,  9, 10, 11, 12, 13, 14, 15, 16],
-    [ 1,  1,  3,  3,  4,  5,  6,  5,  6,  9, 10, 11, 12, 13, 14, 15, 16],
-    [ 2,  3,  2,  3,  4,  5,  6,  5,  6,  9, 10, 11, 12, 13, 14, 15, 16],
-    [ 3,  3,  3,  3,  5,  5,  6,  5,  6,  9, 10, 11, 12, 13, 14, 15, 16],
-    [ 4,  4,  4,  5,  4,  5,  6,  5,  6,  9, 10, 11, 12, 13, 14, 15, 16],
-    [ 5,  5,  5,  5,  5,  5,  9,  5,  9,  9, 10, 12, 12, 13, 15, 15, 16],
-    [ 6,  6,  6,  6,  6,  9,  6,  9,  6,  9, 10, 12, 12, 13, 15, 15, 16],
-    [ 7,  7,  7,  7,  7,  7,  9,  7,  9,  9, 10, 12, 12, 13, 15, 15, 16],
-    [ 8,  8,  8,  8,  8,  9,  8,  9,  8,  9, 10, 12, 12, 13, 15, 15, 16],
-    [ 9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 12, 12, 12, 13, 15, 15, 16],
-    [10, 10, 10, 10, 10, 10, 10, 10, 10, 12, 10, 12, 12, 13, 15, 15, 16],
-    [11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 11, 12, 13, 14, 15, 16],
-    [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 15, 15, 16],
-    [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 16, 16, 16],
-    [14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 14, 15, 16, 14, 15, 16],
-    [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 15, 15, 16],
-    [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
-    ])
-
-typeconv2 = array([
-    ['?','b','B','h','H','i','I','i','I','q','Q','f','d','g','F','D','G'],
-    ['b','b','h','h','H','i','I','i','I','q','Q','f','d','g','F','D','G'],
-    ['B','h','B','h','H','i','I','i','I','q','Q','f','d','g','F','D','G'],
-    ['h','h','h','h','i','i','I','i','I','q','Q','f','d','g','F','D','G'],
-    ['H','H','H','i','H','i','I','i','I','q','Q','f','d','g','F','D','G'],
-    ['i','i','i','i','i','i','q','i','q','q','Q','d','d','g','D','D','G'],
-    ['I','I','I','I','I','q','I','q','I','q','Q','d','d','g','D','D','G'],
-    ['l','l','l','l','l','l','q','l','q','q','Q','d','d','g','D','D','G'],
-    ['L','L','L','L','L','q','L','q','L','q','Q','d','d','g','D','D','G'],
-    ['q','q','q','q','q','q','q','q','q','q','d','d','d','g','D','D','G'],
-    ['Q','Q','Q','Q','Q','Q','Q','Q','Q','d','Q','d','d','g','D','D','G'],
-    ['f','f','f','f','f','d','d','d','d','d','d','f','d','g','F','D','G'],
-    ['d','d','d','d','d','d','d','d','d','d','d','d','d','g','D','D','G'],
-    ['g','g','g','g','g','g','g','g','g','g','g','g','g','g','G','G','G'],
-    ['F','F','F','F','F','D','D','D','D','D','D','F','D','G','F','D','G'],
-    ['D','D','D','D','D','D','D','D','D','D','D','D','D','G','D','D','G'],
-    ['G','G','G','G','G','G','G','G','G','G','G','G','G','G','G','G','G']
-    ],'S1')
+# This compares scalarmath against ufuncs.
 
 class test_types(ScipyTestCase):
     def check_types(self, level=1):
         # list of types
         for k, atype in enumerate(types):
             vala = atype(3)
+            val1 = array([3],dtype=atype)
             for l, btype in enumerate(types):
                 valb = btype(1)
+                val2 = array([1],dtype=btype)
                 val = vala+valb
-                assert val.dtype.num == typeconv[k,l] and \
-                       val.dtype.char == typeconv2[k,l], \
+                valo = val1 + val2
+                assert val.dtype.num == valo.dtype.num and \
+                       val.dtype.char == valo.dtype.char, \
                        "error with (%d,%d)" % (k,l)
+
+if __name__ == "__main__":
+    NumpyTest().run()
