From caec7f21ce3ca2672e93781a379734295c00debe Mon Sep 17 00:00:00 2001
From: Sayed Adel <seiko@imavr.com>
Date: Wed, 30 Dec 2020 10:15:55 +0000
Subject: [PATCH] BUG, BLD: Generate the main dispatcher config header into the
 build dir

  The new path becomes `build/src.*/numpy/distutils/include/npy_cpu_dispatch_config.h`
  instead of `numpy/core/src/common/_cpu_dispatch.h`.

  The new path allows other projects to re-use the CPU dispatcher
  once we decide to expose the following headers:
    - `numpy/core/src/common/npy_cpu_dispatch.h`
    - `numpy/core/src/common/npy_cpu_features.h`
---
 numpy/core/src/common/npy_cpu_dispatch.h |  4 +--
 numpy/distutils/ccompiler_opt.py         | 32 +++++++++++++-----------
 numpy/distutils/command/build_clib.py    | 18 +++++++++----
 numpy/distutils/command/build_ext.py     | 22 +++++++++++-----
 5 files changed, 48 insertions(+), 31 deletions(-)

diff --git a/numpy/core/src/common/npy_cpu_dispatch.h b/numpy/core/src/common/npy_cpu_dispatch.h
index a0f82fa3da0..f69fd2b2ee8 100644
--- a/numpy/core/src/common/npy_cpu_dispatch.h
+++ b/numpy/core/src/common/npy_cpu_dispatch.h
@@ -7,7 +7,7 @@
 #include "npy_cpu_features.h" // NPY_CPU_HAVE
 #include "numpy/utils.h" // NPY_EXPAND, NPY_CAT
 /**
- * Bringing the main configration header '_cpu_dispatch.h'.
+ * Bringing the main configration header 'npy_cpu_dispatch_config.h'.
  *
  * This header is generated by the distutils module 'ccompiler_opt',
  * and contains all the #definitions and headers of instruction-sets,
@@ -33,7 +33,7 @@
         #define NPY__DISPATCH_DEFBOOL
         typedef bool npy__dispatch_bkbool;
     #endif
-    #include "_cpu_dispatch.h"
+    #include "npy_cpu_dispatch_config.h"
     #ifdef NPY_HAVE_VSX
         #undef bool
         #undef vector
diff --git a/numpy/distutils/ccompiler_opt.py b/numpy/distutils/ccompiler_opt.py
index ecf5172ccca..39c08d36b2a 100644
--- a/numpy/distutils/ccompiler_opt.py
+++ b/numpy/distutils/ccompiler_opt.py
@@ -2240,6 +2240,14 @@ def generate_dispatch_header(self, header_path):
         baseline_len = len(baseline_names)
         dispatch_len = len(dispatch_names)
 
+        header_dir = os.path.dirname(header_path)
+        if not os.path.exists(header_dir):
+            self.dist_log(
+                f"dispatch header dir {header_dir} isn't exist, creating it",
+                stderr=True
+            )
+            os.makedirs(header_dir)
+
         with open(header_path, 'w') as f:
             baseline_calls = ' \\\n'.join([
                 (
@@ -2504,30 +2512,24 @@ def _generate_config(self, output_dir, dispatch_src, targets, has_baseline=False
             ))
         return False
 
-def new_ccompiler_opt(compiler, **kwargs):
+def new_ccompiler_opt(compiler, dispatch_hpath, **kwargs):
     """
     Create a new instance of 'CCompilerOpt' and generate the dispatch header
-    inside NumPy source dir.
+    which containing all definitions and headers of instruction-sets for
+    the enabled CPU baseline and dispatch-able features.
 
     Parameters
     ----------
-    'compiler' : CCompiler instance
-    '**kwargs': passed as-is to `CCompilerOpt(...)`
+    compiler : CCompiler instance
+    dispatch_hpath : str
+        path of the dispatch header
 
+    **kwargs: passed as-is to `CCompilerOpt(...)`
     Returns
     -------
     new instance of CCompilerOpt
     """
     opt = CCompilerOpt(compiler, **kwargs)
-    npy_path = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
-    header_dir = os.path.join(npy_path, *("core/src/common".split("/")))
-    header_path = os.path.join(header_dir, "_cpu_dispatch.h")
-    if not os.path.exists(header_path) or not opt.is_cached():
-        if not os.path.exists(header_dir):
-            opt.dist_log(
-                "dispatch header dir '%s' isn't exist, creating it" % header_dir,
-                stderr=True
-            )
-            os.makedirs(header_dir)
-        opt.generate_dispatch_header(header_path)
+    if not os.path.exists(dispatch_hpath) or not opt.is_cached():
+        opt.generate_dispatch_header(dispatch_hpath)
     return opt
diff --git a/numpy/distutils/command/build_clib.py b/numpy/distutils/command/build_clib.py
index a0db6f31f7e..1b3004c2f09 100644
--- a/numpy/distutils/command/build_clib.py
+++ b/numpy/distutils/command/build_clib.py
@@ -118,12 +118,15 @@ def run(self):
         self.compiler.show_customization()
 
         if not self.disable_optimization:
+            dispatch_hpath = os.path.join("numpy", "distutils", "include", "npy_cpu_dispatch_config.h")
+            dispatch_hpath = os.path.join(self.get_finalized_command("build_src").build_src, dispatch_hpath)
             opt_cache_path = os.path.abspath(
-                os.path.join(self.build_temp, 'ccompiler_opt_cache_clib.py'
-            ))
+                os.path.join(self.build_temp, 'ccompiler_opt_cache_clib.py')
+            )
             self.compiler_opt = new_ccompiler_opt(
-                compiler=self.compiler, cpu_baseline=self.cpu_baseline,
-                cpu_dispatch=self.cpu_dispatch, cache_path=opt_cache_path
+                compiler=self.compiler, dispatch_hpath=dispatch_hpath,
+                cpu_baseline=self.cpu_baseline, cpu_dispatch=self.cpu_dispatch,
+                cache_path=opt_cache_path
             )
             if not self.compiler_opt.is_cached():
                 log.info("Detected changes on compiler optimizations, force rebuilding")
@@ -271,7 +274,12 @@ def build_a_library(self, build_info, lib_name, libraries):
         copt_baseline_flags = []
         copt_macros = []
         if not self.disable_optimization:
-            copt_build_src = None if self.inplace else self.get_finalized_command("build_src").build_src
+            bsrc_dir = self.get_finalized_command("build_src").build_src
+            dispatch_hpath = os.path.join("numpy", "distutils", "include")
+            dispatch_hpath = os.path.join(bsrc_dir, dispatch_hpath)
+            include_dirs.append(dispatch_hpath)
+
+            copt_build_src = None if self.inplace else bsrc_dir
             copt_c_sources = [
                 c_sources.pop(c_sources.index(src))
                 for src in c_sources[:] if src.endswith(".dispatch.c")
diff --git a/numpy/distutils/command/build_ext.py b/numpy/distutils/command/build_ext.py
index ca6f8bcd24d..448f7941cd9 100644
--- a/numpy/distutils/command/build_ext.py
+++ b/numpy/distutils/command/build_ext.py
@@ -146,11 +146,16 @@ def run(self):
         self.compiler.show_customization()
 
         if not self.disable_optimization:
-            opt_cache_path = os.path.abspath(os.path.join(self.build_temp, 'ccompiler_opt_cache_ext.py'))
-            self.compiler_opt = new_ccompiler_opt(compiler=self.compiler,
-                                                  cpu_baseline=self.cpu_baseline,
-                                                  cpu_dispatch=self.cpu_dispatch,
-                                                  cache_path=opt_cache_path)
+            dispatch_hpath = os.path.join("numpy", "distutils", "include", "npy_cpu_dispatch_config.h")
+            dispatch_hpath = os.path.join(self.get_finalized_command("build_src").build_src, dispatch_hpath)
+            opt_cache_path = os.path.abspath(
+                os.path.join(self.build_temp, 'ccompiler_opt_cache_ext.py')
+            )
+            self.compiler_opt = new_ccompiler_opt(
+                compiler=self.compiler, dispatch_hpath=dispatch_hpath,
+                cpu_baseline=self.cpu_baseline, cpu_dispatch=self.cpu_dispatch,
+                cache_path=opt_cache_path
+            )
             if not self.compiler_opt.is_cached():
                 log.info("Detected changes on compiler optimizations, force rebuilding")
                 self.force = True
@@ -416,7 +421,12 @@ def build_extension(self, ext):
         copt_baseline_flags = []
         copt_macros = []
         if not self.disable_optimization:
-            copt_build_src = None if self.inplace else self.get_finalized_command("build_src").build_src
+            bsrc_dir = self.get_finalized_command("build_src").build_src
+            dispatch_hpath = os.path.join("numpy", "distutils", "include")
+            dispatch_hpath = os.path.join(bsrc_dir, dispatch_hpath)
+            include_dirs.append(dispatch_hpath)
+
+            copt_build_src = None if self.inplace else bsrc_dir
             copt_c_sources = [
                 c_sources.pop(c_sources.index(src))
                 for src in c_sources[:] if src.endswith(".dispatch.c")
